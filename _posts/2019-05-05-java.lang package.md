---
layout: post
title:  "例外処理"
date:   2019-05-06 00:07:45 +0900
categories: [Java, Japanese]
image: 1.png, 2.png
---

**1.Objectクラス**
&nbsp;
**1.1 Objectクラスのメソッド**
- すべてのクラスの最古の先祖。ただ11個のメソッドだけを持っている。
- notify(),wait()などはスレッドと関連のあるメソッドである。
- equals(),hashcode(),toString()は適切にオーバーライディングしなければならない。
&nbsp;
**1.2 equals(Object obj)**
- 客体自身と与えられた客体を比較する。 同じだったらtrue,違えばfalse。
- Objectクラスに定義されたequals()は参照変数値(客体のアドレス)を比較する。
&nbsp;
```java
public boolean equals() {
	return (this== obj);
}
```
&nbsp;
&nbsp;
- equals()をオーバーライディングして,メンバー変数の値を比較するように変える。
&nbsp;
```java
class Person {
	long id;

	public boolean equals(Object obj) {
		if(obj != null && obj instanceof Person) {
			return id == ((Person)obj).id;
		} else {
			return false;
		}
	}

	Person(long id) {
		this.id = id;
	}
}
```
&nbsp;
**1.3 hashCode()**
- 客体のハッシュコード(intタイプの整数)を返却するメソッド(ハッシュ関数)すなわち多量のデータを保存&検索するヘシン技法に用いられる。
- Objectクラスのhashcode()は客体の内部住所を返還する。
&nbsp;
```java
public class Object {
	public native int hashCode;
}
```
&nbsp;
- equals()をオーバーライディングすると,hashcode()も一緒にオーバーライディングしなければならない。 equals()の結果がtrueである両客体のhashcodeは同じであるからだ。
&nbsp;
```java
String str1=new String("abc");
String str2=new String("abc");
System.out.println(str1.equals(str2)); // true
System.out.println(str1.hashCode); // 96354
System.out.println(str1.hashCode); // 96354
```
&nbsp;
**1.4 toString()**
- 客体の情報を文字列(String)で提供する目的で定義されたメソッド
&nbsp;
```java
class Card {
	String kind;
	int number;

	Card() {
		this("SPADE", 1);
	}
	Card(String kind, int number) {
		this.kind = kind;
		this.number = number;
	}
	@Override
	public String toString() {
		return "Card [kind=" + kind + ", number=" + number + "]";
	}

}

class CardToString {
	public static void main(String[] args) {
		Card c1 = new Card();
		Card c2 = new Card();

		System.out.println(c1.toString());
		System.out.println(c2.toString());
	}
}
```
&nbsp;
**1.5 clone()**
- 客体自身を複製()して新しい客体を生成するメソド
- Cloneableインターフェースを具現したクラスのインスタンスだけが複製できる
- Objectクラスに定義されたclone()はインスタンス変数の値だけを複製する。
- インスタンス変数が参照型である時,参照する客体も複製してオーバーライディングしなければならない。
&nbsp;
```java
Circle c1 = new Circle(new Point(10, 20), 2.0);
Circle c2 = (Circle)c1.clone();

class Circle implements Cloneable {
	Point p;
	double r;

	Circle(Point p, double r) {
		this.p = p;
		this.r = r;
	}

	public Object clone() {
		Object obj = null;
		try {
			obj = super.clone();
		} catch (CloneNotSupportedException e) { }
		Circle c = (Circle)obj;
		c.p = new Point(this.p.x, this.p.y);
		return obj;
	}
}
```
&nbsp;
**1.6 getClass()**
- 自分が属しているクラスのClass客体を返すメソッド
- Class客体はクラスのすべての情報を盛り込んでおり、クルレスダンただし1つだけ存在するクラスファイル`(*.class)`がメモリにロードされる際、生成される。
- Class客体を得る様々な方法
&nbsp;
  - 客体があるとき
```java
Card c = new Card();
Class cObj = c.getClass();
```
&nbsp;
  - 生成された客体がなかったり,客体を使用できないとき
```java
String className = Card.class.getName();
```
&nbsp;
**2.1 Stringクラスの特徴**
- 文字列配列()とそれに関連したメソッドが定義されている。
&nbsp;
```java
public final class String implements java.io.Serializable, Comparable {
	/* The value is used for character storage */
	private char[] value;
}
```
&nbsp;

- Stringインスタンスの内容は変えられない(immutable)
```java
String a= "a";
String a= "b";
String a= "a+ b";
```
![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/java_lang_package/1.png "Screenshot broadcast")

&nbsp;

- String str= "abc";と String str=new String("abc");の比較

![Screenshot broadcast](https://raw.githubusercontent.com/Bullishman/bullishman.github.io/master/static/img/_posts/java_lang_package/2.png "Screenshot broadcast")

&nbsp;
```java
String str1="abc"; // リテラルタイプ
String str2="abc";
String str3=new String("abc"); // インスタンスの生成
String str4=new String("abc");
System.out.println(str1==str2); // False
System.out.println(str3==str4);
System.out.println(str1.equals(str2)); // true
System.out.println(str3.equals(str4));
```
&nbsp;

**2.2空の文字列(""、empty string)**
- 内容がない文字列.大きさが0なchar型配列を保存する文字列
- の大きさが0なの配列を生成するのはどのタイプや可能
```java
char[]cArr=new char[0];//の大きさが0なchar配列
int[]iArr={};		//の大きさが0なchar配列
```
&nbsp;
- String str=';は可能でも char c = ';';は不可能
- Stringは参照型の基本値であるnullより空の文字列で初期化してchar型はデフォルト値が\u0000より空白に、初期化するのが一般的だ。
&nbsp;
**2.4文字列と基本型間の変換**
&nbsp;
- 基本型値を文字列に変える二つの方法
  - 速度:方法1<方法2、可読性:方法1>方法2
  &nbsp;
```java
int I=100;
String str1=i+"";	//100を"100"に変換する方法1
String str2=String.valueOf(i);//100を"100"に変換する方法2
```
&nbsp;
- 文字列を基本型値に変換する方法
&nbsp;
```java
int i=Integer.parseInt("100");//"100"を100に変換する方法1
int i2=Integer.valueOf("100");//"100"を100に変換する方法2(JDK1.5以降)
char c="A"。charAt(0);	//文字列"A"を文字'A'に変換する方法
```
&nbsp;
```java
public static void main(String[] args) {
	String str = "aabbccAABBCCaa";
	System.out.println(str);
	StringCount sc = new StringCount(str);
	System.out.println("aaを "+ sc.stringCount("aa") + "個を見つけました。");
}


public class StringCount
	private int count;
	private String source=';'

	public StringCount(String source) {
		this.count=count;
	}

	public int stringCount(Strings) {
		return stringCount(s、0);
	}

	public int stringCount(Strings, int pos) {
		int index=0;
		if (s== null ||s)。length()==0){
			return 0;
		}
		while (index=source)indexOf(s、pos))!=-1){
			count++;
			Pos=index+s.length();
		}
	}
	return count;
}
```
&nbsp;
**3.1 StringBufferクラスの特徴**
- String のように文字型配列(char[])を内部的に持っている。
```java
public final class StringBuffer implements java.io.Serializable {
	private char
}
```
&nbsp;
- しかし,Stringクラスとは違って内容を変更することができる。 mutable
```java
StringBufer sb= new StringBuffer("abc");
sb.append("123");
```
&nbsp;
- インスタンスを生成するとき,バッファ()の大きさを十分指定した方が良い。 (バッファが低下されば性能低下,すなわち作業中より大きな配列の生成が必要になる。)
