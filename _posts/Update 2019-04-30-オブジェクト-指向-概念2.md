---
layout: post
title:  "2019-04-30-オブジェクト-指向-概念2"
date:   2019-04-30 01:17:02 +0700
categories: [java, japanese]
image: 1.png, 2.png, 3.png, 4.png, 5.png, 6.png, 7.png, 8.png, 9.png, 10.png, 11.png, 12.png
---

**1.相続**

** 1-1相続(inheritance)の定義と長所**
▶ 相続とは?
-  既存のクラスを再使用して新しいクラスを作成すること。
- 二クラスを祖先と子孫の関係を結んでくれること。
- 子孫は祖先のすべてのメンバーを相続される。(生成者,初期化ブロックを除く)
- 子孫のメンバ個数は > 祖先のメンバ個数より少ない (同じや多い)

```java
class Point {

	int x;
	int y;

}
```

```java
class Point3D extends Point {

	int z;

}
```

**1-2-1 クラス間の関係–相続関係(inheritance)**
- 共通部分は祖先で管理し,個別部分は子孫で管理する。
- 祖先の変更は子孫に影響を及ぼすが,子孫の変更は祖先に何の影響も及ぼさない。

```java
class Parent {}
class Child extends Parent {}
class Child2 extends Parent {}
class GrandChild extends Child {}
```

![Screenshot broadcast](https://github.com/Bullishman/bullishman.github.io/blob/master/static/img/_posts/2019-04-23-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88-%E6%8C%87%E5%90%91-%E6%A6%82%E5%BF%B52/1.png "Screenshot broadcast")

**1-2-2クラス間の関係–包含関係(composite)**
▶ 含み(composite)とは?
- 一クラスのメンバー変数で他のクラスを宣言すること
- 小さな単位のクラスを先に作り,これらを組み合わせて一つの大きなクラスを作る。

ex) 

```java
class Circle {// Normal

	int x; // 原点のx座標
	int y; // 原点のy座標
	int r; // 半径(radius)

}

class Point {// Good

	int x; // 原点のx座標
	int y; // 原点のy座標

}

class Circle {// Good

	Point c= new Point();
	int r; // 半径 (radius)

}
```

**1-3-1クラス間の関係の決定する–相続vsを含む**
- できる限り多くの関係を結び,再使用性を高め,管理しやすくする。
- 相続と含みの中でどれを使えばいいか分からなければ,"is-a"と"has-a"を持って文章を作ってみる。

- 円(Circle)は点(Point)である。 - Circle is a Point. // 相続関係
- 円は点(Point)を持っている。 - Circle has a Point. // 含まれ関係



**1-3-2クラス間の関係の決定する–例題説明**
- 円(Circle)は図形(Shape)である。(A circle is a Shape.): 相続関係
- 円(Circle)は点(Point)を有している。 (A circle has a Shape.): 含有関係

```java
class Shape
	String color="blue";
	void draw
		// 図形を描く
	}
}

class Point
	int x;
	int y;

	Point() {)
		this(0、0);
	}

	Point(int x, int y) {)
		this.x=x;
		this.y=y;
	}
}

class Circle extends Shape
	Point center;
	int r;

	Circle
		this(new Point(0、0)、100);
	}
	
	Circle (Point center, int r) {
		this.center=center;
		this.r=r;
	}	
}

Circle c1 = new Circle();
Circle c2 = new Circle(new Point(150, 150), 50);


class Triangel extends Shape {
	Point[] = p;
	
	Triangle(Point[] p) {
		this.p = p;
	}

	Triangle(Point p1, Point p2, Point p3) {
		P = new Point[]{p1, p2, p3};
	}
}

Point[] p = {new Point(100, 100),
	   new Point(140, 50),
	   new Point(200, 100),
	   };

Triangle t1 = new Triangle(p);
```

**1-3-3クラス間の関係の決定する–例題説明2**

```java
package ch7;

public class DeckTest {
	public static void main(String[] args) {
		Deck d = new Deck(); //　カード一セーとを作る。
		Card c = d.pick(0); //　混ぜり前に一番上のカードを抜く。
		System.out.println(c); // System.out.println(c.toString())と同じ.
		
		d.shuffle(); // カードを混ぜる。
		c = d.pick(0); //　混ぜり後に一番上のカードを抜く。
		System.out.println(c);
	}
}

class Deck {
	final int CARD_NUM = 52;　//　カードの回数。
	Card cardArr[] = new Card[CARD_NUM];　//　Card客体配列を含む・
	
	Deck() {
		int i = 0;
		
		for(int k = Card.KIND_MAX; k > 0; k--)
			for(int n = 0; n < Card.NUM_MAX ; n++)
				cardArr[i++] = new Card(k, n+1);
 	}
	
	Card pick(int index) { 
// 指定された位置(index)にあるカード一つを取り出して返却。
		return cardArr[index];
	}
	
	Card pick() { // Deckでカード一つを選ぶ。
		int index = (int)(Math.random() * CARD_NUM);
		return pick(index);
	}
	
	void shuffle() {
		for(int i=0; i < cardArr.length; i++) {
			int r = (int)(Math.random() * CARD_NUM);
			
			Card temp = cardArr[i];
			cardArr[i] = cardArr[r];
			cardArr[r] = temp;
		}
	}
} //Deckクラスの終わり。

class Card {
	static final int KIND_MAX = 4; 	//　カード 模様の数量。
	static final int NUM_MAX = 13;	//　模様別の数量。
	
	static final int SPADE = 4;
	static final int DIAMOND = 3;
	static final int HEART = 2;
	static final int CLOVER = 1;
	int kind;
	int number;
	
	Card() {
		this(SPADE, 1);
	}

	Card(int kind, int number) {
		this.kind = kind;
		this.number = number;
	}

	@Override
	public String toString() {
		String[] kinds = {"", "CLOVER", "HEART", "DIAMOND", "SPADE"};
		String numbers = "0123456789XJQK"; // 数字10はXで表示。
		return "Card [kind=" + kinds[this.kind] + ", number=" + numbers.charAt(this.number) + "]";
	} // toString()の終わり。
} // Cardクレスの終わり。
```

![Screenshot broadcast](https://github.com/Bullishman/bullishman.github.io/blob/master/static/img/_posts/2019-04-23-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88-%E6%8C%87%E5%90%91-%E6%A6%82%E5%BF%B52/2.png "Screenshot broadcast")

**1-4 単一相続(single inheritance)**
- Javaは単一相続のみを許容する。

ex)
// 比重の高いクラスだけを相続関係とし,残りは含めて関係とする。

```java
class Tv {
	boolean power;
	int channel;

	void power() { power = !power; }
	void channelUp() { ++channel; }
	void channelDown() { --channel; }
}

class VCR {
	boolean power;
	int counter = 0;
	void power() { power = !power; }
	void play() {/*内容の省略*/ }
	void stop() {/*内容の省略*/ }
	void rew()  {/*内容の省略*/ }
	void ff()      {/*内容の省略*/ }
}

class TVCR extends Tv { // 相続
	VCR vcr = new VCR(); // 含み
	int counter = vcr.counter;

	void play () {
		vcr.play();
	}

	void stop () {
		vcr.stop();
	}

	void rew () {
		vcr.rew();
	}

	void ff () {
		vcr.ff();
	}

}
```

**1-5 Objectクラス–すべてのクラスの最高潮上**
- 先祖のないクラスでは自動的にObjectクラスの相続が受けられる。
- 相続階層度の最上位にはObjectクラスがある。
- すべてのクラスはObjectクラスに定義された11個のメソッドを相続している。(toString, equals(Object obj), hashCode(), ...)


**2-1オボライディン(overriding)とは?**
- "先祖クラスから相続したメソッドの内容を相続するクラスに合わせて変更することをオーバーライディングという"

```java
class Point
	int x;
	int y;

	String getLocation
		return "x:" + x + ", y:" + y;
	}
}

class Point3D extends Point{
	intz;
	String getLocation
		return "x:" + x + ", y:" + y + ", z:" + z; 
	}

}
```

**2-2 オボライディンの条件**

- 1.宣言付加のようでなければならない。 (名前、媒介変数、リターンタイプ)
- 2.アクセス制御者を狭い範囲で変更できない。先祖のメソッドがプロテクトドなら,範囲が同じか広いprotectedやpublicのだけ変更できる。
- 3.先祖クラスのメソッドよりも多くの例外を宣言できない。

```java
class Parent
	void parentMethod () throws IOException, SQLException
		//..
	}
}
class Child extends Parent {
	void parentMethod () throws IOException, SQLException
		//..
	}
}
class Child2 extends Parent{
	void parentMethod) throws Exception
		//..
	}
}
```

**2-3 オーバーロードvsオボライディン**
オーバーロード - 従来に無い新しいメセードを定義すること (new)
オーバーライディング - 相続されたメザードの内容を変更すること (change, modify)


**2-4 super–参照変数(1/2) **
- this - インスタンス自身を指す参照変数 インスタンスの住所が保存されていること すべてのインスタンス·メソッドに地域変数として隠されたまま存在
- 先祖のメンバーと自分のメンバーを区別するのに使用

ex1) 

```java
class Parent {
	int x = 10;
}

class Child extends Parent {
	int x = 20;
	void method() {
		System.out.println(“x=” + x); // 20
		System.out.println(“this.x=” + this.x); // 20
		System.out.println(“super.x=” + super.x); // 10 

	}
}
```

ex2)

```java
class Point {
	int x;
	int y;

	String getLocation() {
		return “x :” + x + “, y :" + y;
	}
}

class Point3D extends Point {
	int z;
	String getLocation() {
		return “x :” + x + “, y:” + y + “, z:” + z; 
		return super.getLocation + “, z:” + z; 

	}

}
```

**2-5 super()–先祖の生成者(1/3)**
- 子孫クラスのインスタンスを生成すると,子孫のメンバーと先祖のメンバーが合わさった一つのインスタンスが生成される。
- 先祖のメンバーたちも初期化されなければならないので,子孫の生成者の最初の文章から先祖の生成者を呼び出さなければならない。
- Objectクラスを除いたすべてのクラスの生成者最初の行には生成者(同じクラスの他の生成者または先祖の生成者)を呼び出ししなければならない、そうでなければ、コンパイラが自動的に"super();"を生成者の最初の行に挿入する。

```java
class Point extends Object {
		int x;
		int y;

		Point() {
			this(0, 0);
		}

		Point(int x, int y) {
			super(); // Object();
			this.x = x;
			this.y = y;
		}
}
```

**2-5 super()–先祖の生成者(2/3)**

```java

class PointTest {
		public static void main(String args[]) {
			Point3D p3 = new Point3D(1, 2, 3);
		}
}

class Point {
		int x;
		int y;

		Point (int x, int y) {
			super(); // Object();
			this.x = x;
			this.y = y;
		}

		String getLocation() {
			return “x :” + x + “, y :” + y;
		}

}

class Point3D extends Point {
		int z;

		Point3D(int x, int y, int z) {
			// 先祖の生成者Point(int x, int y)を呼び出す。
			super(x, y);
			this.z = z;
		}

}
```

**3-1 パッケージ(package)**
- お互いに関連されたクラスとインターフェースの結び。
- クラスが物理的にクラスファイル(*.class)であるように,パッケージは物理的なフォルダーである。 また,パッケージはサブパッケージがて,。"."に区分される。
- クラスの実名(full name)はパッケージ名が含まれたことである。(Stringクラスのfull nameはjava.lang.String)
- rt.jarはJava APIの基本クラスなどを圧縮したファイル (JDK設置経路\jre\libに位置)

**3-2 パッケージの宣言**
- パッケージはソースファイルに最初の文章(注釈を除く)でたった一度宣言する。
- 一つのソースファイルに二つ以上のクラスが含まれた場合、いずれも同様のパッケージに属することになる。(一つのソースファイルにただ一つのpublicクラスだけを許容する。)
- 全てのクラスは一つのパッケージに属し,パッケージが宣言されていないクラスは自動的に無名の(unnamed)パッケージに属することになる。

**3-3-1 クラスパス(classpath)設定(1/2)**
- クラスパス(classpath)はクラスファイル(*.class)を探す経路。区分者は';'。
- クラスパスにパッケージが含まれたフォルダーやjarファイルを(*.jar)羅列する。
- クラスパスがなければ自動的に現在のフォルダが含まれるが、クラスパスを指定するときは,現在のフォルダー(。)も一緒に追加しなければならない。

**3-3-2 クラスパス(classpath)設定(2/2)**
- クラスパスで自動含まれたフォルダー for クラスファイル(*.class):修正すべきJDK設置経路\jre\classes
- クラスパスで自動含まれたフォルダー· for jarファイル(*.class):JDK設置の際,姉妹性になる。 JDK設置経路\jre\lib\t

**3-4 import文**
- 使うクラスが入っているパッケージを指定するのに使用。
- import文を使えばクラスを使う時,パッケージ名を省略することができる。
- java.langパッケージのクラスでは,importしなくても使える。(String, Object, System, Thread .....)

**3-5 import文の宣言**
- import文はパッケージ文とクラス宣言の間に宣言する。
一般的なソースファイル(*.java)の構成は次の順序からなっている。package文 - import文 - クラス宣言 

- 名前が同じクラスが属した二つのパッケージをimportする時はクラスの前にパッケージ名をつけてくれなければならない。

```java
import java.sql.;
import java.util.;

public class Import Test
		public static void main
			java.util.Date today = new java.util.Date;
		}
}
```

**4-1 ジェオジャ(modifier)とは?**
- クラス,変数,メソッドの宣言部に使用され,付加的な意味を与える。
-  制御者は大きくアクセス制御者とその他の制御者に分かれる。
- 一つの対象に複数の制御者を組み合わせて使用できるが,アクセス制御者はただ一つ使用できる


